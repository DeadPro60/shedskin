#summary documentation

=Shed Skin Documentation=

Version 0.8, July 24 2011, Mark Dufour and James Coughlan

<wiki:toc max_depth="1" />

= Introduction =

**Shed Skin** is an experimental **Python-to-C++ compiler** designed to speed up the execution of computation-intensive Python programs. It converts programs written in a restricted subset of Python to C++. The C++ code can be compiled to executable code, which can be run either as a standalone program or as an extension module easily imported and used in a regular Python program.

**Shed Skin** uses type inference techniques to determine the implicit types used in a Python program, in order to generate the explicit type declarations needed in a C++ version. Because C++ is statically typed, **Shed Skin** requires Python code to be written such that all variables are (implicitly!) statically typed.

Besides the typing and subset restrictions, supported programs cannot freely use the Python standard library, although 22 common modules are supported, such as *random* and *re* (see [#Library_Limitations Library Limitations]).

Additionally, the type inference techniques employed by **Shed Skin** currently do not scale very well beyond several thousand lines of code (the largest compiled program is about 3,000 lines (sloccount)). In all, this means that **Shed Skin** is currently mostly useful to compile smallish programs and extension modules, that do not make extensive use of dynamic Python features or the standard or external libraries. See [http://gitorious.org/shedskin/mainline/trees/master/examples here] for about 60 example programs.

Because **Shed Skin** is still in an early stage of development, it can also improve a lot. At the moment, you will probably run into some bugs when using it. Please report these, so they can be fixed!

At the moment, **Shed Skin** is compatible with Python versions 2.4 to 2.7, behaves like 2.6, and should work on Windows and most UNIX platforms, such as GNU/Linux and OSX. On UNIX platforms, GCC version 4.2 or higher is required to compile the resulting C++ code.

= Typing Restrictions =

**Shed Skin** translates pure, but implicitly statically typed, Python programs into C++. The static typing restriction means that variables can only ever have a single, static type. So, for example, 

{{{
a = 1
a = '1' # bad
}}}

is not allowed. However, as in C++, types can be abstract, so that for example,

{{{
a = A()
a = B() # good
}}}

where *A* and *B* have a common base class, is allowed.

The typing restriction also means that the elements of some collection (*list*, *set*, etc.) cannot have different types (because their subtype must also be static). Thus:

{{{
a = ['apple', 'b', 'c'] # good
b = (1, 2, 3) # good
c = [[10.3, -2.0], [1.5, 2.3], []] # good
}}}

is allowed, but

{{{
d = [1, 2.5, 'abc'] # bad
e = [3, [1, 2]] # bad
f = (0, 'abc', [1, 2, 3]) # bad
}}}

is not allowed. Dictionary keys and values may be of different types:

{{{
g = {'a': 1, 'b': 2, 'c': 3} # good
h = {'a': 1, 'b': 'hello', 'c': [1, 2, 3]} # bad
}}}

In the current version of **Shed Skin**, mixed types are also permitted in tuples of length two:

{{{
a = (1, [1]) # good
}}}

In the future, mixed tuples up to a certain length will probably be allowed.

*None* may only be mixed with non-scalar types (i.e., not with *int*, *float* or *complex*):

{{{
l = [1]
l = None # good

m = 1
m = None # bad

def fun(x = None): # bad: use a special value for x here, e.g. x = -1
    pass
fun(1)
}}}

Integers and floats can often be mixed, but it is better to avoid this where possible, as it may confuse **Shed Skin**:

{{{
a = [1.0]
a = [1] # wrong - use a float here, too
}}}

= Python Subset Restrictions =

**Shed Skin** will only ever support a subset of all Python features. The following common features are currently not supported:

 * *eval*, *getattr*, *hasattr*, *isinstance*, meta classes, anything really dynamic
 * arbitrary-size arithmetic (integers become 32-bit by default on most architectures, see [#Command-line_Options Command-line Options])
 * variable numbers of arguments and keyword arguments
 * multiple inheritance
 * nested functions and classes
 * unicode
 * inheritance from builtins (excluding *Exception* and *object*)
 * overloading `__iter__` and `__call__`
 * closures

Some other features are currently only partially supported:

 * class attributes must always be accessed using a class identifier:

{{{
        self.class_attr # bad
        SomeClass.class_attr # good
        SomeClass.some_static_method() # good
}}}

 * function references can be passed around, but not method references, and they cannot be contained:

{{{
        var = lambda x, y: x+y # good
        var = some_func # good
        var = self.some_method # bad, method reference
        [var] # bad, contained
}}}

= Library Limitations =

Programs to be compiled with **Shed Skin** cannot freely use the Python standard library. At the moment, the following 24 modules are largely supported. Several of these, such as *os.path*, were compiled to C++ using **Shed Skin**.

 * *array*
 * *binascii*
 * *bisect*
 * *collections* (defaultdict, deque)
 * *ConfigParser* (no SafeConfigParser)
 * *copy*
 * *csv* (no Dialect, Sniffer)
 * *datetime*
 * *fnmatch*
 * *getopt*
 * *glob*
 * *heapq*
 * *itertools* (no starmap)
 * *math*
 * *mmap*
 * *os*
 * *os.path*
 * *random*
 * *re*
 * *socket*
 * *string*
 * *struct* (no Struct, pack_into, unpack_from)
 * *sys*
 * *time*

Note that any other module, such as *pygame*, *pyqt* or *pickle*, may be used in combination with a Shed Skin generated [#Generating_an_Extension_Module extension module]. For examples of this, see the [http://gitorious.org/shedskin/mainline/trees/master/examples Shed Skin examples].

See [#How_to_help_out_in_Development How to help out in Development] on how to help improve or add to the set of supported modules.

= Installation =

There are four types of downloads available: a self-extracting *Windows* installer, a *Debian* (*Ubuntu*) package, an *RPM* package, and a *UNIX* tarball.

==Windows==

To install the *Windows* version, simply download and start it. (If you use *ActivePython* or some other non-standard Python distribution, or *MingW*, please deinstall this first.)

==Debian (Ubuntu)==

To install the *Debian* package, simply download and install it using your package manager. Make sure the following packages are installed (at least version 4.2 of `g++`):

{{{
sudo apt-get install g++ libpcre3-dev libgc-dev python-dev
}}}

==RPM==

To install the *RPM* package, simply download and install it using your package manager. Make sure the following packages are installed (at least version 4.2 of `gcc-g++`):

{{{
sudo yum install gcc-c++ pcre-devel gc-devel python-devel
}}}

==UNIX==

To install the **UNIX** tarball on a *GNU/Linux* or *OSX* system, take the following steps:

 * download and unpack it
 * run `sudo python setup.py install`
 * For *OSX*: install the Apple XCode development environment
 * make sure you can run `g++`, the C++ compiler (version 4.2 or higher)
 * install the [http://www.hpl.hp.com/personal/Hans_Boehm/gc/ Boehm garbage collector] (including development files)

If the Boehm garbage collector is not available via your package manager, the following is known to work. Download for example version 7.2alpha6 from the [http://www.hpl.hp.com/personal/Hans_Boehm/gc/ website], unpack it, and install it as follows:

{{{
./configure --prefix=/usr/local --enable-threads=posix --enable-cplusplus --enable-thread-local-alloc --enable-large-config
make
make check
sudo make install
}}}

 * install the [http://www.pcre.org/ PCRE library] (including development files)

If the PCRE library is not available via your package manager, the following is known to work. Download for example version 8.12 from the [http://www.pcre.org/ website], unpack it, and build as follows:

{{{
./configure --prefix=/usr/local
make
sudo make install
}}}

 * make sure the Python development files are installed

= Compiling a Stand-Alone Program = 

Under Windows, first execute (double-click) the ``init.bat`` file in the directory where you installed **Shed Skin**.

To compile the following simple test program, called ``test.py``: ::

    print 'hello, world!'

Type: ::

    shedskin test

This will create two C++ files, called ``test.cpp`` and ``test.hpp``, as well as a ``Makefile``.

To create an executable file, called ``test`` (or ``test.exe``), type: ::

    make

= Generating an Extension Module =

To compile the following program, called ``simple_module.py``, as an extension module: ::

    # simple_module.py

    def func1(x):
        return x+1

    def func2(n):
        d = dict([(i, i*i)  for i in range(n)])
        return d

    if __name__ == '__main__':
        print func1(5)
        print func2(10)

Type: ::

    shedskin -e simple_module
    make

For 'make' to succeed on a non-Windows system, make sure to have the Python development files installed (under **Debian**, install ``python-dev``; under **Fedora**, install ``python-devel``).

Note that for type inference to be possible, the module must (indirectly) call its own functions. This is accomplished in the example by putting the function calls under the ``if __name__=='__main__'`` statement, so that they are not executed when the module is imported. Note that functions only have to be called indirectly, so if ``func2`` calls ``func1``, the call to ``func1`` can be omitted.

The extension module can now be simply imported and used as usual: ::

    >>> from simple_module import func1, func2
    >>> func1(5)
    6
    >>> func2(10)
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

**Limitations**

There are some important differences between using the compiled extension module and the original.

1. Only builtin scalar and container types (``int``, ``float``, ``complex``, ``str``, ``list``, ``tuple``, ``dict``, ``set``, ``frozenset``) as well as ``None`` and instances of user-defined classes can be passed/returned. So for instance, anonymous functions and iterators are currently not supported.

2. Builtin objects are completely converted for each call/return from **Shed Skin** to **CPython** types and back, including their contents. This means you cannot change **CPython** builtin objects from the **Shed Skin** side and vice versa, and conversion may be slow. Instances of user-defined classes can be passed/returned without any conversion, and changed from either side.

3. Global variables are converted once, at initialization time, from **Shed Skin** to **CPython**. This means that the value of the **CPython** version and **Shed Skin** version can change independently. This problem can be avoided by only using constant globals, or by adding getter/setter functions.

4. Multiple (interacting) extension modules are not supported at the moment. Also, importing and using the Python version of a module and the compiled version at the same time may not work.

**Numpy Integration**

**Shed Skin** does not currently come with direct support for **Numpy**. It is possible however to pass a **Numpy** array to a **Shed Skin** compiled extension module as a list, using its ``tolist`` method. Note that this is very inefficient (see above), so it is only useful if a relatively large amount of time is spent inside the extension module. Consider the following example: ::

    # simple_module2.py

    def my_sum(a):
        """ compute sum of elements in list of lists (matrix) """
        h = len(a) # number of rows in matrix
        w = len(a[0]) # number of columns
        s = 0.0
        for i in range(h):
            for j in range(w):
                s += a[i][j]
        return s

    if __name__ == '__main__':
        print my_sum([[1.0, 2.0], [3.0, 4.0]]) 

After compiling this module as an extension module with **Shed Skin**, we can pass in a **Numpy** array as follows: ::

    >>> import numpy
    >>> import simple_module2
    >>> a = numpy.array(([1.0, 2.0], [3.0, 4.0]))
    >>> simple_module2.my_sum(a.tolist())
    10.0

= Distributing Binaries = 

= Parallel Processing =

= Calling C/C++ Code =

= Command-line Options = 

= Performance Tips and Tricks =

= How to help out in Development =